#!/usr/bin/env python
"""
This module provides functionality for controlling a matrix display using serial communication.
It includes definitions for command values, functions to send commands and render matrices, and
    a main loop to update the display.
Classes:
    CommandVals (IntEnum): Enumeration of command values used for controlling the matrix display.
Functions:
    send_serial(dev, command): Sends a serial command using an existing serial connection.
    send_command(dev, command, parameters=None, with_response=False): Sends a command to the
        specified device.
    send_command_raw(dev, command, with_response=False): Sends a raw command to the device, opening
        a new serial connection each time.
    send_col(dev, s, x, vals): Stages grayscale values for a single column.
    commit_cols(dev, s): Commits the changes from sending individual columns, displaying the matrix.
    render_matrix(dev, matrix): Shows a black/white matrix by sending everything in a single
        command.
    print_matrices(): Prints matrices with a border and specific symbols for matrix values.
    write_columns(device, serial_device, col_vals): Writes column values to a device and commits
        the changes.
    signal_handler(_sig, _frame): Handles the SIGINT signal (Ctrl+C) to gracefully shut down the
    program.
Global Variables:
    RIGHT_DEVICE (str): Path to the right device.
    LEFT_DEVICE (str): Path to the left device.
    WIDTH (int): Width of the matrix.
    HEIGHT (int): Height of the matrix.
    RESPONSE_SIZE (int): Size of the response expected from the device.
    FWK_MAGIC (list): Magic numbers used in commands.
    matrices (dict): Dictionary containing matrices for left, right, and default devices.
    left_matrix (serial.Serial): Serial connection to the left matrix device.
    right_matrix (serial.Serial): Serial connection to the right matrix device.
    ROW (int): Current row being updated in the main loop.
"""

import signal
import sys
from time import sleep

from device import Device
from matrix import Matrix
from writers import CpuWriter


left_device_address = "/dev/ttyACM1"
right_device_address = "/dev/ttyACM0"

left_device = Device(location=left_device_address, name="Left Matrix")
# right_device = Device(location=right_device_address, name="Right Matrix")

print((0, left_device.HEIGHT - 1 - 18))
print((3, left_device.HEIGHT - 1))

cpu_writer = CpuWriter(
    left_device.ON,
    left_device.OFF,
    (0, left_device.HEIGHT - 1 - 18),
    (4, left_device.HEIGHT - 1),
)

left_matrix = Matrix(left_device, [cpu_writer])


def signal_handler(_sig, _frame):
    """
    Handle the SIGINT signal (Ctrl+C) to gracefully shut down the program.

    This function is called when the user presses Ctrl+C. It performs the following actions:
    1. Prints a message indicating that Ctrl+C was pressed.
    2. Renders the default state of the left and right matrices.
    3. Closes the left and right matrices.
    4. Exits the program with a status code of 0.

    Args:
        sig (int): The signal number.
        frame (FrameType): The current stack frame.
    """

    left_matrix.stop()

    sys.exit(0)


signal.signal(signal.SIGINT, signal_handler)


left_matrix.start_modules()

while left_matrix.running:
    sleep(10)

# right_matrix = Matrix(right_device)

# test_matrix = [[Device.ON for _ in range(Device.HEIGHT)] for _ in range(Device.WIDTH)]


# left_matrix.set_matrix(test_matrix)
# right_matrix.set_matrix(test_matrix)

# left_matrix.reset_matrix()
# right_matrix.reset_matrix()

# left_device.close()
# right_device.close()

# signal.signal(signal.SIGINT, signal_handler)

# discard = psutil.cpu_percent()

# send_command(left_matrix, CommandVals.BRIGHTNESS, [5])

# # Print CPU Usage
# while True:
#     matrices[LEFT_DEVICE] = [row[:] for row in matrices["default"]]
#     cpu_percentage = str(round(psutil.cpu_percent()))
#     # cpu_percentage = "100"

#     cpu_cols = len(cpu_percentage)
#     top_row = 7
#     if cpu_cols == 1:
#         start_row = 29
#         top_row = 29
#     elif cpu_cols == 2:
#         start_row = 23
#         top_row = 23
#     else:
#         start_row = 17
#         top_row = 17

#     for char in cpu_percentage:
#         matrices[LEFT_DEVICE] = write_number(char, matrices[LEFT_DEVICE], start_row, 0)
#         start_row += 6

#     gpu_info = json.loads(
#         subprocess.check_output(
#             ["/home/joelwilkins/nvtop-dev/usr/local/bin/nvtop", "-s"]
#         )
#     )

#     gpu_util = gpu_info[0]["gpu_util"][:-1]
#     gpu_cols = len(gpu_util)

#     # print(gpu_util)

#     if gpu_cols == 1:
#         start_row = 29
#         top_row = top_row if top_row < 29 else 29
#     elif gpu_cols == 2:
#         start_row = 23
#         top_row = top_row if top_row < 23 else 23
#     else:
#         start_row = 17
#         top_row = 17

#     for char in gpu_util:
#         matrices[LEFT_DEVICE] = write_number(char, matrices[LEFT_DEVICE], start_row, 6)
#         start_row += 6

#     print_divider(matrices[LEFT_DEVICE], top_row)
#     print_c(matrices[LEFT_DEVICE], top_row)
#     print_g(matrices[LEFT_DEVICE], top_row)
#     # os.system('clear')
#     # print_matrices()

#     render_matrix(left_matrix, matrices[LEFT_DEVICE])
#     sleep(1)
