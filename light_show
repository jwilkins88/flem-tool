#!/usr/bin/env python
"""
This module provides functionality for controlling a matrix display using serial communication.
It includes definitions for command values, functions to send commands and render matrices, and
    a main loop to update the display.
Classes:
    CommandVals (IntEnum): Enumeration of command values used for controlling the matrix display.
Functions:
    send_serial(dev, command): Sends a serial command using an existing serial connection.
    send_command(dev, command, parameters=None, with_response=False): Sends a command to the
        specified device.
    send_command_raw(dev, command, with_response=False): Sends a raw command to the device, opening
        a new serial connection each time.
    send_col(dev, s, x, vals): Stages grayscale values for a single column.
    commit_cols(dev, s): Commits the changes from sending individual columns, displaying the matrix.
    render_matrix(dev, matrix): Shows a black/white matrix by sending everything in a single
        command.
    print_matrices(): Prints matrices with a border and specific symbols for matrix values.
    write_columns(device, serial_device, col_vals): Writes column values to a device and commits
        the changes.
    signal_handler(_sig, _frame): Handles the SIGINT signal (Ctrl+C) to gracefully shut down the
    program.
Global Variables:
    RIGHT_DEVICE (str): Path to the right device.
    LEFT_DEVICE (str): Path to the left device.
    WIDTH (int): Width of the matrix.
    HEIGHT (int): Height of the matrix.
    RESPONSE_SIZE (int): Size of the response expected from the device.
    FWK_MAGIC (list): Magic numbers used in commands.
    matrices (dict): Dictionary containing matrices for left, right, and default devices.
    left_matrix (serial.Serial): Serial connection to the left matrix device.
    right_matrix (serial.Serial): Serial connection to the right matrix device.
    ROW (int): Current row being updated in the main loop.
"""

import signal
import sys
import os
from time import sleep

from led_device import LedDevice
from matrix import Matrix
from led_device import LedDevice
from models.config import Config
from models import ConfigSchema
from modules import load_module

CONFIG: Config = None
CONFIG_SCHEMA: ConfigSchema = ConfigSchema()
CONFIG_PATH = "config.json"
if not os.path.exists(CONFIG_PATH):
    print(f"Configuration file {CONFIG_PATH} not found.")
    sys.exit(1)

with open(CONFIG_PATH, encoding="utf-8") as config_file:
    CONFIG = CONFIG_SCHEMA.loads(config_file.read())

devices: list[LedDevice] = []
matrices: list[Matrix] = []


for device in CONFIG.devices:
    device_to_add = LedDevice(device)
    devices.append(device_to_add)

    device_modules = []
    for module in device.modules:
        device_modules.append(load_module(module))
    matrices.append(Matrix(device_to_add, device_modules))


def signal_handler(_sig, _frame):
    """
    Handle the SIGINT signal (Ctrl+C) to gracefully shut down the program.

    This function is called when the user presses Ctrl+C. It performs the following actions:
    1. Prints a message indicating that Ctrl+C was pressed.
    2. Renders the default state of the left and right matrices.
    3. Closes the left and right matrices.
    4. Exits the program with a status code of 0.

    Args:
        sig (int): The signal number.
        frame (FrameType): The current stack frame.
    """

    for matrix in matrices:
        matrix.stop()

    sys.exit(0)


signal.signal(signal.SIGINT, signal_handler)

print(matrices)
for matrix in matrices:
    matrix.start_modules()


any_matrix_running = True

while any_matrix_running:
    for matrix in matrices:
        if matrix.running:
            any_matrix_running = True
            break
        any_matrix_running = False

    # todo check for config updates

    sleep(10)

# left_device = Device(location=left_device_address, name="Left Matrix")
# # right_device = Device(location=right_device_address, name="Right Matrix")

# cpu_module = CpuModule(
#     left_device.ON,
#     left_device.OFF,
#     (0, left_device.HEIGHT - 1 - 18),
#     (3, left_device.HEIGHT - 1),
# )

# left_matrix = Matrix(left_device, [cpu_module])


# left_matrix.start_modules()

# while left_matrix.running:
#     sleep(10)

# right_matrix = Matrix(right_device)

# test_matrix = [[Device.ON for _ in range(Device.HEIGHT)] for _ in range(Device.WIDTH)]


# left_matrix.set_matrix(test_matrix)
# right_matrix.set_matrix(test_matrix)

# left_matrix.reset_matrix()
# right_matrix.reset_matrix()

# left_device.close()
# right_device.close()

# signal.signal(signal.SIGINT, signal_handler)

# discard = psutil.cpu_percent()

# send_command(left_matrix, CommandVals.BRIGHTNESS, [5])

#     gpu_info = json.loads(
#         subprocess.check_output(
#             ["/home/joelwilkins/nvtop-dev/usr/local/bin/nvtop", "-s"]
#         )
#     )

#     gpu_util = gpu_info[0]["gpu_util"][:-1]
#     gpu_cols = len(gpu_util)

#     # print(gpu_util)

#     if gpu_cols == 1:
#         start_row = 29
#         top_row = top_row if top_row < 29 else 29
#     elif gpu_cols == 2:
#         start_row = 23
#         top_row = top_row if top_row < 23 else 23
#     else:
#         start_row = 17
#         top_row = 17

#     for char in gpu_util:
#         matrices[LEFT_DEVICE] = write_number(char, matrices[LEFT_DEVICE], start_row, 6)
#         start_row += 6

#     print_divider(matrices[LEFT_DEVICE], top_row)
#     print_c(matrices[LEFT_DEVICE], top_row)
#     print_g(matrices[LEFT_DEVICE], top_row)
#     # os.system('clear')
#     # print_matrices()

#     render_matrix(left_matrix, matrices[LEFT_DEVICE])
#     sleep(1)
